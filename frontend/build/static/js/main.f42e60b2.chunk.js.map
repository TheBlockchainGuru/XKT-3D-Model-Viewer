{"version":3,"sources":["utils/Viewer.js","utils/Viewers.js","store/store.js","component/XKTModel.js","component/UploadFiles.js","App.js","utils/serviceWorker.js","index.js"],"names":["makeViewer","LoaderPlugin","ModelViewer","this","props","camera","bcfViewpoint","setUpViewer","setCamera","loadPlugins","perfModels","loadModels","setBCFViewpoints","pickEntity","prevProps","currentProps","models","toAdd","difference","toRemove","map","el","modelLoader","load","forEach","elID","id","viewer","scene","destroy","canvasID","Viewer","canvasId","eye","look","up","zoom","promises","model","Promise","resolve","on","all","then","BCFViewpointsPlugin","setViewpoint","navCubeSettings","NavCubePlugin","eventToPickOn","lastEntity","lastColorize","input","coords","hit","pick","canvasPos","console","log","entity","colorize","slice","imageData","getSnapshot","format","link","document","createElement","setAttribute","click","width","height","enableScreenshot","className","canvasWidth","canvasHeight","type","onClick","takeScreenshot","Component","defaultProps","XKTViewer","GLTFLoaderPlugin","XKTLoaderPlugin","store","create","set","currentModel","src","edges","performacne","updateCurrentModel","value","produce","state","XKTModel","window","innerWidth","innerHeight","UploadFiles","style","position","left","top","background","getUploadParams","meta","url","onSubmit","files","allFiles","data","FormData","i","length","append","file","error","axios","post","res","catch","err","warn","maxFiles","accept","styles","dropzone","overflow","border","App","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"0NAOaA,EAAa,SAACC,GAAkB,IACrCC,EADoC,uKAExC,WAAoB,MAEeC,KAAKC,MAA9BC,EAFU,EAEVA,OAAQC,EAFE,EAEFA,aAGhBH,KAAKI,cAIDF,GAAQF,KAAKK,YAGjBL,KAAKM,cAGL,IAAMC,EAAaP,KAAKQ,aAGpBL,GAAcH,KAAKS,iBAAiBF,GAIxCP,KAAKU,eAxBiC,gCA4BxC,SAAmBC,GAAY,IAAD,OACtBC,EAAeZ,KAAKC,MAO1B,GAAIU,EAAUE,SAAWD,EAAaC,OAAQ,CAC5C,IAAMC,EAAQC,qBAAWH,EAAaC,OAAQF,EAAUE,QAClDG,EAAWD,qBAAWJ,EAAUE,OAAQD,EAAaC,QAErDN,EAAaO,EAAMG,KAAI,SAAAC,GAAE,OAAI,EAAKC,YAAYC,KAAKF,MAErDN,EAAaT,cAAcH,KAAKS,iBAAiBF,GAErDS,EAASK,SAAQ,SAACH,GAChB,IAAMI,EAAOJ,EAAGK,GACG,EAAKC,OAAOC,MAAMZ,OAAOS,GACjCI,gBA/CuB,kCAqDxC,WACE1B,KAAKwB,OAAOE,YAtD0B,yBA2DxC,WAAe,IACLC,EAAa3B,KAAKC,MAAlB0B,SAER3B,KAAKwB,OAAS,IAAII,IAAO,CACvBC,SAAUF,MA/D0B,uBAmExC,WAAa,IACHzB,EAAWF,KAAKwB,OAAOC,MAAvBvB,OADE,EAUNF,KAAKC,MAAMC,OALb4B,EALQ,EAKRA,IACAC,EANQ,EAMRA,KACAC,EAPQ,EAORA,GACAC,EARQ,EAQRA,KAIF/B,EAAO4B,IAAMA,EACb5B,EAAO6B,KAAOA,EACd7B,EAAO8B,GAAKA,EACZ9B,EAAO+B,KAAKA,KAlF0B,8BAqFxC,SAAiBpB,GAAS,IAAD,OACfV,EAAiBH,KAAKC,MAAtBE,aAcF+B,EAAWrB,EAAOI,KACtB,SAAAkB,GAAK,OAAI,IAAIC,SAAQ,SAAAC,GAAO,OAAIF,EAAMG,GAAG,SAAUD,SAKrDD,QAAQG,IAAIL,GAAUM,MAAK,kBAAM,EAAKC,oBAAoBC,aAAavC,QA1GjC,wBA6GxC,WAAc,IAAD,OAEX,OADmBH,KAAKC,MAAhBY,OACMI,KAAI,SAAAkB,GAAK,OAAI,EAAKhB,YAAYC,KAAKe,QA/GX,yBAoHxC,WAAe,IAAD,EAC8BnC,KAAKC,MAAvCE,EADI,EACJA,aAAcwC,EADV,EACUA,gBACtB3C,KAAKmB,YAAc,IAAIrB,EAAaE,KAAKwB,QAIrCrB,IACFH,KAAKyC,oBAAsB,IAAIA,IAAoBzC,KAAKwB,SAKtDmB,GAEF,IAAIC,IAAc5C,KAAKwB,OAAQmB,KAlIK,wBA2IxC,WAAc,IACJE,EAAkB7C,KAAKC,MAAvB4C,cAEJC,EAAa,KACbC,EAAe,KAEXtB,EAAUzB,KAAKwB,OAAfC,MAERA,EAAMuB,MAAMV,GAAGO,GAAe,SAACI,GAC7B,IAAMC,EAAMzB,EAAM0B,KAAK,CACrBC,UAAWH,IAGTC,GAEFG,QAAQC,IAAIJ,EAAIK,OAAOhC,IAClBuB,GAAcI,EAAIK,OAAOhC,KAAOuB,EAAWvB,KAC1CuB,IACFA,EAAWU,SAAWT,GAExBD,EAAaI,EAAIK,OACjBR,EAAeG,EAAIK,OAAOC,SAASC,QACnCP,EAAIK,OAAOC,SAAW,CAAC,EAAK,EAAK,KAE1BV,IACTA,EAAWU,SAAWT,EACtBD,EAAa,WArKqB,4BA0KxC,WACE,IAAMY,EAAY1D,KAAKwB,OAAOmC,YAAY,CACxCC,OAAQ,QAOJC,EAAOC,SAASC,cAAc,KACpCF,EAAKG,aAAa,OAAQN,GAC1BG,EAAKG,aAAa,WAAY,oBAC9BH,EAAKI,UAtLiC,oBAyLxC,WAAU,IAAD,SAOHjE,KAAKC,MALP0B,EAFK,EAELA,SACAuC,EAHK,EAGLA,MACAC,EAJK,EAILA,OACAxB,EALK,EAKLA,gBACAyB,EANK,EAMLA,iBAEF,OACE,gCACE,wBACE7C,GAAII,EACJuC,MAAOA,EACPC,OAAQA,EACRE,UAAU,uDAEX1B,EACC,wBACEpB,GAAIoB,EAAgBd,SACpBqC,MAAOvB,EAAgB2B,YACvBH,OAAQxB,EAAgB4B,aACxBF,UAAU,2BAEV,KACHD,EACC,wBACEI,KAAK,SACLjD,GAAG,kBACH8C,UAAU,kBACVI,QAAS,kBAAM,EAAKC,kBAJtB,6BAQE,YA1N8B,GAChBC,aAwP1B,OAJA5E,EAAY6E,aAAe,CACzB/B,cAAe,gBAGV9C,G,gBC1PI8E,GADahF,EAAWiF,KACZjF,EAAWkF,M,iCCUrBC,EAbDC,KAAO,SAAAC,GAAG,MAAK,CACzBC,aAAc,CACV5D,GAAI,QACJ6D,IAAI,kBAEJC,OAAO,EACPC,aAAa,GAEjBC,mBAAoB,SAACC,GAAD,OAAWN,EAAIO,aAAQ,SAAAC,GACvCA,EAAMP,aAAN,eAAyBK,YCQlBG,EAfE,WAChB,IAAMxD,EAAQ6C,GAAM,SAAAU,GAAK,OAAIA,EAAMP,gBAEnC,OACC,8BACC,cAACN,EAAD,CACElD,SAAS,aACTuC,MAAO0B,OAAOC,WACd1B,OAAQyB,OAAOE,YACfjF,OAAQ,CAACsB,Q,0CCuBC4D,EAhCY,WAiBvB,OACI,qBAAKC,MAAO,CAAEC,SAAU,QAASC,KAAM,EAAGC,IAAK,EAAGhC,OAAQ,QAASD,MAAO,IAAKkC,WAAY,SAA3F,SACI,cAAC,IAAD,CACIC,gBAlBY,SAAC,GAAa,EAAXC,KAAa,MAAO,CAAEC,IAAK,6BAmB1CC,SAjBS,SAACC,EAAOC,GAEzB,IADA,IAAMC,EAAO,IAAIC,SACRC,EAAI,EAAGA,EAAIH,EAASI,OAAQD,IACjCF,EAAKI,OAAO,OAAQL,EAASG,GAAGG,MAEpC3D,QAAQ4D,MAAMP,EAAS,IACvBQ,IAAMC,KAAK,mCAAoCR,GAAMnE,MAAK,SAAA4E,OAEvDC,OAAM,SAAAC,GACLjE,QAAQkE,KAAKD,OASTE,SAAU,EACVC,OAAO,aACPC,OAAQ,CACJC,SAAU,CAAEC,SAAU,SAAUC,OAAQ,OAAQ1D,OAAQ,eCf7D2D,G,MATH,WACX,OACC,sBAAKzD,UAAU,MAAf,UACC,cAAC,EAAD,IACA,cAAC,EAAD,SCEiB0D,QACW,cAA7BnC,OAAOoC,SAASC,UAEe,UAA7BrC,OAAOoC,SAASC,UAEhBrC,OAAOoC,SAASC,SAASC,MACvB,2DCbNC,IAASC,OAAO,cAAC,EAAD,IAAStE,SAASuE,eAAe,SD4H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMhG,MAAK,SAAAiG,GACjCA,EAAaC,kB","file":"static/js/main.f42e60b2.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Viewer } from '@xeokit/src/viewer/Viewer';\nimport { BCFViewpointsPlugin } from '@xeokit/src/plugins/BCFViewpointsPlugin/BCFViewpointsPlugin';\nimport { NavCubePlugin } from '@xeokit/src/plugins/NavCubePlugin/NavCubePlugin';\nimport {difference} from 'lodash';\n\nexport const makeViewer = (LoaderPlugin) => {\n  class ModelViewer extends Component {\n    componentDidMount() {\n      // Get the necessary props with some nice destructuring\n      const { camera, bcfViewpoint } = this.props;\n\n      // First, we instantiate the viewer with the canvasID\n      this.setUpViewer();\n\n      // If there's any camera settings passed through props\n      // let's apply them here\n      if (camera) this.setCamera();\n\n      // Then we load the necessary plugins\n      this.loadPlugins();\n\n      // Then we load the model(s)\n      const perfModels = this.loadModels();\n\n      // Set the bcfViewpoint if there's any\n      if (bcfViewpoint) this.setBCFViewpoints(perfModels);\n\n      // The picker function is called on the scene with\n      // the desired event type (e.g. mouseclicked, mousemove, etc)\n      this.pickEntity();\n    }\n\n    // Whenever the props change, this method will run\n    componentDidUpdate(prevProps) {\n      const currentProps = this.props;\n\n      // Whenever the models prop changes, we want to add/remove\n      // the respective models that were added to/removed from the\n      // models array\n      // We use lodash's difference function to compare the previous &\n      // current props\n      if (prevProps.models !== currentProps.models) {\n        const toAdd = difference(currentProps.models, prevProps.models);\n        const toRemove = difference(prevProps.models, currentProps.models);\n\n        const perfModels = toAdd.map(el => this.modelLoader.load(el));\n\n        if (currentProps.bcfViewpoint) this.setBCFViewpoints(perfModels);\n\n        toRemove.forEach((el) => {\n          const elID = el.id;\n          const elToRemove = this.viewer.scene.models[elID];\n          elToRemove.destroy();\n        });\n      }\n    }\n\n    // Destroy/clean up viewer on component unmount\n    componentWillUnmount() {\n      this.viewer.destroy();\n    }\n\n    // Instantiate the viewer and store it on the component\n    // instance so that any of our methods can have access to it\n    setUpViewer() {\n      const { canvasID } = this.props;\n\n      this.viewer = new Viewer({\n        canvasId: canvasID,\n      });\n    }\n\n    setCamera() {\n      const { camera } = this.viewer.scene;\n\n      // Get camera settings from props\n      const {\n        eye,\n        look,\n        up,\n        zoom,\n        // eslint-disable-next-line react/destructuring-assignment\n      } = this.props.camera;\n\n      camera.eye = eye;\n      camera.look = look;\n      camera.up = up;\n      camera.zoom(zoom);\n    }\n\n    setBCFViewpoints(models) {\n      const { bcfViewpoint } = this.props;\n      // bcf viewpoints are only tied to models in that there might\n      // be some entities pre-selected on the model(s)\n\n      // say we have 2 models and 1 bcf viewpoint\n      // in that viewpoint is a selection array with entity IDs\n      // we have IDs from both our models\n      // for us to be able to load and render them properly, we have to\n      // make sure that both those models have loaded\n\n      // since the xeokit sdk has no convenience method that lets us\n      // perform actions when all models have been loaded into a scene\n      // we have to wrap each model loaded event with a promise\n      // on the load event we immediately call the resolve function\n      const promises = models.map(\n        model => new Promise(resolve => model.on('loaded', resolve)),\n      );\n\n      // once all the models have been loaded and thus all the promises\n      // have been resolved, we can finally load our viewpoint\n      Promise.all(promises).then(() => this.BCFViewpointsPlugin.setViewpoint(bcfViewpoint));\n    }\n\n    loadModels() {\n      const { models } = this.props;\n      return models.map(model => this.modelLoader.load(model));\n    }\n\n    // We store the plugins on the component instance too for the\n    // same reason we did with the viewer\n    loadPlugins() {\n      const { bcfViewpoint, navCubeSettings } = this.props;\n      this.modelLoader = new LoaderPlugin(this.viewer);\n\n      // Only instantiate the BCFViewpointsPlugin if there are any\n      // bcfViewpoints passed through props\n      if (bcfViewpoint) {\n        this.BCFViewpointsPlugin = new BCFViewpointsPlugin(this.viewer);\n      }\n\n      // Only instantiate the NavCubePlugin if there are any\n      // navcube settings passed through props\n      if (navCubeSettings) {\n        // eslint-disable-next-line no-new\n        new NavCubePlugin(this.viewer, navCubeSettings);\n      }\n    }\n\n    // Attempt to pick an entity\n    // Highlight each entity successfully picked\n    // Log picked entity's id to the console\n    // the click event will be the default if there's nothing\n    // else explicitly passed through\n    pickEntity() {\n      const { eventToPickOn } = this.props;\n\n      let lastEntity = null;\n      let lastColorize = null;\n\n      const { scene } = this.viewer;\n\n      scene.input.on(eventToPickOn, (coords) => {\n        const hit = scene.pick({\n          canvasPos: coords,\n        });\n\n        if (hit) {\n          // eslint-disable-next-line no-console\n          console.log(hit.entity.id);\n          if (!lastEntity || hit.entity.id !== lastEntity.id) {\n            if (lastEntity) {\n              lastEntity.colorize = lastColorize;\n            }\n            lastEntity = hit.entity;\n            lastColorize = hit.entity.colorize.slice();\n            hit.entity.colorize = [0.0, 1.0, 0.0];\n          }\n        } else if (lastEntity) {\n          lastEntity.colorize = lastColorize;\n          lastEntity = null;\n        }\n      });\n    }\n\n    takeScreenshot() {\n      const imageData = this.viewer.getSnapshot({\n        format: 'png',\n      });\n\n      // The anchor element's download tag enables us to save the\n      // screenshot to the file system\n      // we don't actually append the link to the page\n      // we just call the click event on it to start/prompt the download\n      const link = document.createElement('a');\n      link.setAttribute('href', imageData);\n      link.setAttribute('download', 'model-screenshot');\n      link.click();\n    }\n\n    render() {\n      const {\n        canvasID,\n        width,\n        height,\n        navCubeSettings,\n        enableScreenshot,\n      } = this.props;\n      return (\n        <div>\n          <canvas\n            id={canvasID}\n            width={width}\n            height={height}\n            className=\"d-block mx-auto border border-secondary m-3 mw-100\"\n          />\n          {navCubeSettings ? (\n            <canvas\n              id={navCubeSettings.canvasId}\n              width={navCubeSettings.canvasWidth}\n              height={navCubeSettings.canvasHeight}\n              className=\"d-block mx-auto mw-100\"\n            />\n          ) : null}\n          {enableScreenshot ? (\n            <button\n              type=\"button\"\n              id=\"take-screenshot\"\n              className=\"btn btn-primary\"\n              onClick={() => this.takeScreenshot()}\n            >\n              Take Screenshot\n            </button>\n          ) : null}\n        </div>\n      );\n    }\n  }\n\n  ModelViewer.propTypes = {\n    canvasID: PropTypes.string.isRequired,\n    width: PropTypes.number,\n    height: PropTypes.number,\n    camera: PropTypes.object,\n    models: PropTypes.arrayOf(\n      PropTypes.shape({\n        id: PropTypes.string.isRequired,\n        src: PropTypes.string.isRequired,\n      }),\n    ).isRequired,\n    bcfViewpoint: PropTypes.object,\n    eventToPickOn: PropTypes.string,\n    navCubeSettings: PropTypes.shape({\n      canvasId: PropTypes.string.isRequired,\n      canvasWidth: PropTypes.number,\n      canvasHeight: PropTypes.number,\n    }),\n    enableScreenshot: PropTypes.bool,\n  };\n\n  ModelViewer.defaultProps = {\n    eventToPickOn: 'mouseclicked',\n  };\n\n  return ModelViewer;\n};\n","/* eslint-disable import/order */\nimport { makeViewer } from './Viewer';\nimport { GLTFLoaderPlugin } from '@xeokit/src/plugins/GLTFLoaderPlugin/GLTFLoaderPlugin';\nimport { XKTLoaderPlugin } from '@xeokit/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin';\n\nexport const GLTFViewer = makeViewer(GLTFLoaderPlugin);\nexport const XKTViewer = makeViewer(XKTLoaderPlugin);\n","import create from \"zustand\";\r\nimport produce from \"immer\";\r\n\r\nconst store = create(set => ({\r\n    currentModel: {\r\n        id: 'model',\r\n        src: `./xkt/model.xkt`,\r\n        // metaModelSrc: `./xkt/model.json`,\r\n        edges: true,\r\n        performacne: true,\r\n    },\r\n    updateCurrentModel: (value) => set(produce(state => {\r\n        state.currentModel = {...value};\r\n    })),\r\n}))\r\n\r\nexport default store","import React from 'react';\nimport { XKTViewer } from '../utils/Viewers';\n\nimport store from '../store/store';\n\nconst XKTModel = () => {\n\tconst model = store(state => state.currentModel);\n\n\treturn (\n\t\t<div>\n\t\t\t<XKTViewer\n\t\t\t  canvasID=\"canvas-xkt\"\n\t\t\t  width={window.innerWidth}\n\t\t\t  height={window.innerHeight}\n\t\t\t  models={[model]}\n\t\t\t/>\n\t\t</div>\n\t);\n};\n\nexport default XKTModel;\n","import React from 'react';\r\nimport 'react-dropzone-uploader/dist/styles.css';\r\nimport Dropzone from 'react-dropzone-uploader';\r\nimport axios from 'axios';\r\n\r\nexport const UploadFiles = () => {\r\n\r\n    const getUploadParams = ({ meta }) => { return { url: 'https://httpbin.org/post' } }\r\n\r\n    const handleSubmit = (files, allFiles) => {\r\n        const data = new FormData();\r\n        for( let i = 0; i < allFiles.length; i++ ) {\r\n            data.append('file', allFiles[i].file);\r\n        }\r\n        console.error(allFiles[0]);\r\n        axios.post(\"http://178.62.53.223:4000/upload\", data).then(res => {\r\n\r\n        }).catch(err => {\r\n            console.warn(err);\r\n        });\r\n    }\r\n\r\n    return (\r\n        <div style={{ position: 'fixed', left: 0, top: 0, height: '100vh', width: 400, background: 'white' }}>\r\n            <Dropzone\r\n                getUploadParams={getUploadParams}\r\n                onSubmit={handleSubmit}\r\n                maxFiles={2}\r\n                accept=\".xkt,.json\"\r\n                styles={{\r\n                    dropzone: { overflow: 'hidden', border: 'none', height: '100vh' },\r\n                }}\r\n            />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default UploadFiles;","import React from 'react';\nimport XKTModel from './component/XKTModel';\nimport UploadFiles from './component/UploadFiles';\n\nimport './style.css';\n\nconst App = () => {\n\treturn (\n\t\t<div className=\"app\">\n\t\t\t<XKTModel />\n\t\t\t<UploadFiles />\n\t\t</div>\n\t)\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./utils/serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}